## 三 原型链
#### 3.1 原型链介绍
每个对象都有构造函数；
每个构造函数都有原型对象prototype（函数也是对象，所以每个构造函数也有prototype）；
每个构造函数的原型都是一个对象，那么这个原型对象也有构造函数，这个构造函数也有原型对象；
这样形成了一个链式结构，成为原型链；
最终的对象为Object。
#### 3.2 属性搜索原则
```
1、先在自身实例查找
2、再去当前对象的原型中查找
3、再找原型的原型对象...依次向上查找
4、最后查找Objct.prototype
5、找不到报错
```
#### 3.3 原型链关系图
![](/images/JavaScript/JavaScript-02.png)
比如一个 Person构造函数，一个实例对象 p:
```
Person.prototype.constructor = Person;

p.constructor = Person
p._proto_ = Person.prototype                //理解这里很关键，原型的作用就是共享数据，节省空间
p._proto_.constructor = Person

p._proto_.constructor = Person.prototype.constructor
```
那么如何判断对象是不是这个数据类型？
- 第一种方法：实例对象.构造器是否等于构造函数名
- 第二种方法： 对象 instanceof 构造函数名  （推荐）
注意：需要共享的数据才会写在原型中，一般创建对象时肯定不会共享数据，而是共享方法，所以才会有创建对象时候上述推荐的创建方式。

注意下列代码：
```js
function Person(name) {
   this.name = name;
   this.run = function(){
      console.log(111);
   }
}

Person.prototype.name = "lisi";
Person.prototype.run = function(){
   console.log(222);
}

let p = new Person("zs");
console.log(p.name)        //只输出zs
console.log(p.run())       //先输出111 再输出 undefined
```
原型链：
对象内部都包含__proto__，那么会指向某个原型对象，这样依次往上递推，最后到达Object的原型对象，Object的原型对象的__proto__指向了[Function]
Object的原型对象prototype指向{}
```js
console.log(Object.__proto__);      //[Function]
console.log(Object.prototype);      //{}
```
知识点：我们不推荐扩展内置对象，但是可以使用下列方法更安全的扩展。
```javascript
function MyArray() {}
MyArray.prototype = new Array();    //MyArray即成为了具备和Array一样的功能
```