## 一 对象的创建
#### 1.1 方式一 字面量
```javascript
    var obj = {
        name : "张学友",
        sayHello : function () {
            console.log("Hello World");
        }
    }
```
缺点：不能把JSON对象当做模板来统一进行new操作，只能使用点语法一个一个赋值。
#### 1.2 Object创建
```javascript
var p = new Object();
p.age = 13;
```
缺点：同字面量
#### 1.3 构造函数创建
```javascript
function Person() {     //首字母大写用来强调自己是构造函数
    this.name = "尼古拉斯凯奇";  //不添加this类似于window.name 会污染全局
    this.age = 50;      
    this.sayHello = function () {
        console.log("Hello World");
    }
}
var p = new Person();  
p.sayHello();
```
说明：
- 构造函数是用来初始化对象的，new才是用来创建对象的
- 构造函数如果没有参数，new调用构造函数时，可以省略括号
- 构造函数如果没有return，会把构造函数内的this对象返回给对象
new的执行过程：
- 1 开辟空间，创建一个空对象
- 2 把this指向这个空对象
- 3 把空对象的内部原型 指向 构造函数的原型
- 4 构造函数如果没有return，把空对象返回
  - 如果return了基本数据类型，则仍然返回这个空对象
  - 如果return了复杂数据类型，则替换掉空对象
伪代码演示new过程：
```
 function Cat(){

     this = {};		                //1

     this.__proto__ = Cat.prototype;	//2

     this.age = 18;			//3

     this.show = function(){console.log(123)};

     return this;			//4

 }

```
#### 1.4 原型创建
如果使用同一个构造函数创建多个对象，该对象内部使用了同样的构造方法，但是这些构造方法都是新申请的，会造成资源浪费，我们可以在外部将这个通用函数书写出来，但是又在成了全局污染。  
解决方案：
```
在构造函数被创建出来的时候，系统会默认帮构造函数创建并关联一个空对象，即——原型对象，可以通过下面的方式获得：
构造函数.prototype

原型中的成员都可以被相应构造函数创建的对象所使用。  
利用这个特点，我们可以将构造函数中的函数，放到原型中存储，就解决了全局变量污染，资源浪费问题。
```
代码如下：

```javascript
//构造函数：构造函数中的方法将覆盖原型中的同名方法
function Cat(name){
    this.name = name;
}

//原型添加成员的两种方式
Cat.prototype.eat = function () {
    console.log("原型eat....");
}
Cat.prototype["dance"] = function () {
    console.log("原型dance...");
}

var c = new Cat("Green");
c.eat();
c.dance();
```
注意：
- 1 点语法赋值时，会直接给对象设置属性，对象没有该属性，将直接添加。不会去原型中查找、修改。
- 2 原型中的属性是引用类型时，所有对象共有该属性，且一个对象对其进行修改，其他对象都会受到影响。
- 3 一般情况下，不会将属性放在原型中，原型中只存放共享方法。原型上如果有属性，只有原型自己能修改这个属性。

上述多个方法绑定在prototype上，也可以简便书写：
```js
Cat.prototype = {
    constructor: Cat,       //需要手动书写构造器指向，如果没有该句，则创建的对象会少了constructor属性。
    eat: function(){},
    dance: function(){}
}
    console.log("原型eat....");
}
Cat.prototype["dance"] = function () {
    console.log("原型dance...");
}

```
当然为了避免参数传递顺序错误，我们一般给构造函数的参数是 json 格式。
#### 1.5 工厂函数创建
通常也可以使用工厂模式创建对象，该部分属于设计模式的范畴：
```js
function createPerson(name,age) {
    const obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.run = function() {
        console.log("running...");
    }
    return obj;
}
const p = createPerson("lisi",30);
```
工厂函数与构造函数都可以创建对象，传递参数，但是：
- 构造函数首字母大写
- 构造函数没有new和返回值
- 构造函数使用this作为当前对象，工厂函数使用new后的对象作为当前对象
## 二 对象的使用
#### 2.1 对象添加成员
JS中的键值对组合其实就是对象，我们可以直接通过 点语法 或者 [] 来给对象添加成员。
```javascript
var obj = {
    name : "lisi",
    age : 30
};
obj[0] = function () {
    console.log("添加成功");
}
obj[{}] = function () {        //类似添加了 obj["object Object"]
    console.log("添加成功");
}
console.log(obj);   
//{ '0': [Function],name: 'lisi',age: 30,'[object Object]': [Function] }
```
#### 2.2 方法调用顺序
- 1 在对象自己内部查找
- 2 在原型中查找
- 3 以上属性没找到即undefined，方法没找到就会报错 not a function
#### 2.3 如何访问原型
构造函数访问原型：	构造函数.prototype
实例对象访问原型：	实例对象.__proto__
由于部分浏览器不支持实例对象访问原型的方法，所以不推荐这样使用，仅在调试时使用。
#### 2.4 对象属性
如果实例对象也创建了一个和原型一样的属性（属性名一样），那么不会去修改原型的值，而是给实例对象自己添加了属性。读取属性先找实例对象自己的，如果没有再去找原型。
注意：如果使用替换的方式替换原型，如果新原型没有constructor属性，会影响三角关系，为保证   构造函数--原型---对象 三者的合理，应在替换时候手动加入constructor属性。
```javascript
Person.prototype = {
    constructor : Person
};
```
所以我们创建对象还可以这样创建：
```javascript
function Person(name) {
    this.name = name;
}
var p1 = new Person("zs");
console.log(Person.prototype.constructor);
console.log(p1.constructor); //直接用对象访问原型中的属性

var p2 = new p1.constructor("lisi"); //相当与使用了构造函数创建
console.log(p2.name);

```




