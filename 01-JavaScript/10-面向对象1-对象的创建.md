## 一 对象的创建

### 1.1 方式一 对象直接量
```js
    var obj = {
        name : "张学友",
        sayHello : function () {
            console.log("Hello World");
        }
    }
    console.log(obj.name);      // 点语法直接访问属性
```

### 1.2 方式二 Object创建

```js
var p = new Object();
p.age = 13;
```

### 1.3 方式三 构造函数创建
```js
function Person() {     //首字母大写用来强调自己是构造函数
    this.name = "尼古拉斯凯奇";  //不添加this类似于window.name 会污染全局
    this.age = 50;      
    this.sayHello = function () {
        console.log("Hello World");
    }
}
var p = new Person();  
p.sayHello();
```

## 二 构造函数与new

构造函数：
> 构造函数是用来描述对象内部数据结构的

构造函数只是对对象内部数据的描述，并没有达到创建对象的作用，`new`操作才是创建了对象。   

说明：
- 构造函数如果没有参数，new调用构造函数时，可以省略括号。不过笔者极度不建议！
- 构造函数如果没有return，会把构造函数内的this对象返回给对象

new的执行过程：
- 1 开辟空间，创建一个空对象
- 2 把this指向这个空对象
- 3 把空对象的内部原型 指向 构造函数的原型
- 4 如果new时候需要传参，将参数赋值给this
- 5 无论有没有return，都会默认返回this，
  - 如果写明return了一个引用类型，则产生的对象是该引用类型
  - 如果写明return了一个基本类型，则仍然返回this

伪代码演示new过程：
```
     this = {};		                        // 1、2
     this.__proto__ = 构造函数.prototype;	 // 3
     this.age = 18;			                // 4 
     return this;			                // 5
```

## 三 创建对象的方式延伸

笔者认为对象的创建其实在第一节中阐述完毕，大多数编程语言的对象创建方式无非也都是上述三种或者对应的变体。  

但是这三种方式是最基础的创建方式，我们往往需要对创建对象时，还要对对象进行一系列的加工，这里引申出两种创建方式：
- 工厂函数
- 原型

### 3.1 利用工厂函数创建

利用工厂模式创建对象并不是创建对象的方式，而是属于软件工程领域的设计模式范畴，提现了软开工程的哲学思想：

```js
function createPersonFactory(age) {

    var obj = new Object();
    obj.age = age;

    if (age < 18 ) {
        obj.des = "小孩";
    } else {
        obj.des = "大人";
    }

    obj.run = function() {
        console.log(obj.des + " 跑步...");
    }
    return obj;
}
var p = createPersonFactory(30);
p.run();
```

利用工厂函数可以实现对象的一些自定义补充。

## 3.2 利用原型创建对象

使用构造函数创建对象时，构造函数本身会关联一个空的原型对象：
- 该对象可以通过 `构造函数.prototype` 获得
- 该对象的属性，可以通过 构造函数new出的对象 直接获得

示例：
```js
function Person(name){
    this.name = name;
}
Person.prototype.run = function(){
    console.log(this.name + " is running");
}

var p = new Person("lisi");
p.run();
```

这种创建对象的好处是：避免资源浪费与全局污染。假设构造函数内部有很多函数，那么每次new对象时，这些这些构造方法都是新申请的，会造成资源浪费，我们如果将这些对象的通用函数写在外部，又会造成全局污染。如果将通用函数挂载到构造函数本身的一个内部属性上，就不会出现这些问题了。  

现在看几个需要注意的问题：
- 如果有构造函数内部的属性/方法与原型对象的属性/方法重名，则对象获取到的是构造函数的属性/方法
- new出的对象都会共享原型中的属性/方法，所以一个对象对原型对象进行修改，其他对象都会受到影响
- 一般情况下，不会将属性放在原型中，原型中只存放共享方法。原型上如果有属性，只有原型自己能修改这个属性。

示例：
```js
function Person(name){
    this.name = name;
    this.run = function(){          // 具备优先执行权
        console.log("构造函数内函数执行：" + this.name + " is running");
    }
}

Person.prototype.name = "zs";
Person.prototype.age = 30;
Person.prototype.run = function(){
    console.log("原型对象内函数执行：" + this.name + " is running");
}

var p = new Person("lisi");
console.log(p.name);
p.run();
```


上述多个方法绑定在prototype上，也可以简便书写：
```js
Person.prototype = {
    constructor: Person,       //需要手动书写构造器指向，如果没有该句，则创建的对象会少了constructor属性。
    eat: function(){},
    dance: function(){}
}
```

### 3.3 Oject.create()方法创建对象

ES5中提供了`Oject.create()`方法：
```js
var obj = Object.create({name:"lisi", age:13});
console.log(obj.name);
```

注意：该方法传入参数为null时，会创建一个没有原型的新对象，不会继承任何东西，甚至不能使用`toString()`这样的基础方法，所以创建空对象的方式是：
```js
var obj = Object.create(Object.prototype);
```

利用该特性可以实现JS面向对象的继承。  