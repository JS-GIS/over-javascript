## 七 函数
#### 7.1 函数声明
```javascript
//方式一：直接量声明
function fn1(){
    console.log("函数1");
}
fn1();

//方式二：Function关键字声明
var fn2 = new Function("console.log('函数2')");
fn2();

//方式三：函数表达式
var fn3 = function(){
    console.log("函数3");
}
fn3();
```
#### 7.2 全局变量和局部变量
全局变量：又称成员变量，在哪里都可访问到，如进入script立即定义的变量和没有var的变量。
局部变量：函数内部的变量，只有函数内部可以访问到。
隐式全局变量：隐藏的全局变量不好被发现。
```javascript
function fn() {
    // b和c就是隐式全局变量（等号）
    var  a  =  b  =  c  =  1;  
    // b和c就是隐式全局变量（分号） 
    var  a = 1;  b = 2;  c = 3;     
}
```
#### 7.3 变量提升与预解析
在函数体内部声明变量，会把该声明提升到函数体的顶端， 是只提升声明、不赋值。
```javascript
function fn(){
    console.log(num);   //输出undefined。因为num其实在console上已经声明
    var num = 1;
}
fn();
```
变量提升：在预解析的时候，成员变量和函数被提升到最高位置，方便其他程序访问。
变量提升特点：成员变量只提升变量名，不提升变量值，但是函数会提升所有内容。
当使用的变量在定义变量之前时，很容易出现变量提升。
#### 7.4 参数
arguments存储的是传递过来的实参，JS在创建函数的同时，会在函数内部创建一个arguments对象实例，arguments对象只有函数开始时才可用。
arguments对象并不是一个数组，访问单个参数的方式与访问数组元素的方式相同。
arguments对象的长度由实参个数决定，而不是由形参个数决定。
```javascript
function fn(a,b){
    console.log(fn.length);     //输出：函数的形参的个数 2
    console.log(arguments);     //输出：{ '0': 1, '1': 2 }
    console.log(arguments.length); // 输出实参个数2
}
fn(1,2);
```
#### 7.5 返回值
在函数内部用return来返回计算结果，一个函数只能返回一个值，同时会终止代码的执行。
如果函数没有显式的使return语句 ，那么函数有默认的返回值：undefined；
如果函数使用return，但return后面没有任何值，函数返回值也是：undefined；
#### 7.6 函数加载问题
JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。
#### 7.7 匿名函数
匿名函数就是没有名字的函数，书写相对简洁。
匿名函数的调用有三种方法：
- 直接调用或自调用。(function(){alert(1)})()
- 事件绑定。
- 定时器。


## 二 函数调用 apply call bind
```javascript
    var name = "Lisi";

    function sayHi() {
        console.log(this.name);
    }

    var obj = {
        name: "zs"
    }

    sayHi();            //输出Lisi
    sayHi.apply(obj);   //输出zs，修改了this指向
    sayHi.call(obj);    //输出zs，修改了this指向
```
apply与call的使用：
```
函数名.apply(绑定对象,函数参数列表数组);
函数名.call(绑定对象,函数参数1,参数2,参数3....);
```
案例：
```javascript
    var name = "Lisi";

    function sayHi(a, b) {
        console.log(this.name + "拥有" + (a*b) + "个项目");
    }

    var obj = {
        name: "zs"
    }

    sayHi(3,4);                 //输出 Lisi拥有12个项目
    sayHi.apply(obj,[3,4]);     //输出 zs拥有12个项目
    sayHi.call(obj,3,4);        //输出 zs拥有12个项目
```
apply和call使用场景：
- apply用于函数的形参个数不确定的情况；
- call用于确定了函数的形参有多少个的时候使用；
- apply和call的第一个参数都为null时，表示为函数调用模式，即this指向window
使用案例一：求数组最大值
```javascript
var arr = [9,1,4,10,7];
var max1 = Math.max(9,1,4,10,7);
var max2 = Math.max.apply(null,arr);
console.log(max1);      //输出10
console.log(max2);      //输出10
```
使用案例二：伪数组
```javascript
//obj是个伪数组，无法使用obj.0获取属性，也无法像数组那样用obj[0]获取
var obj = {
    0: "a",
    1: "b",
    2: "c",
    length: 3
};
// [].concat(1,2,3)会产生数组[1,2,3]
var arr = [].concat.apply([], obj);
console.log(arr);                       //输出['a','b','c']
```
bind：bind函数的返回值是函数本身
```js
function fn(x){
    console.log(x + '---' + this);
}

var f1 = fn.bind(); //bind是复制的意思，参数可以在此时传入，也可以在复制后调用时传入
f1(3);   //3

var f2 = fn.bind(null);
f1(3);  //3

```

## 三 作用域与变量提升
#### 3.1 作用域分类
- 块级作用域：代码块级别的作用域。JavaScript中没有块级作用域。但是ES6中提供了 let const 等支持块级类似块级作用域。
- 词法作用域：在代码写好的那一刻，变量的作用域已经确定。JS支持词法作用域！！！与词法作用域对应的是动态作用域。
```js
      var a = 123;
      function f1(){
        console.log(a);
      }

      function f2(){
        var a = 456;
        f1();
      }
      f2();                      //得到结果123---这里是词法作用域，执行f1()，直接进入f1()内部查找变量，找不到，去全局查找
                                  //如果是动态作用域,执行f1(),应该先在f1所处环境找，结果是456
 ```
 在JavaScript中只有函数能产生作用域！！！
 #### 3.2 预解析变量提升
JavaScript代码在预解析阶段，会对以var声明的变量名，和function开头的语句块，进行提升操作（hoisting）
变量提升：
- 首先将以var声明的变量名
- 以function开头的函数进行提升
- 执行
伪代码：
```js

预解析函数同名：后面的函数会替换前面的函数
func1();
function func1(){
    console.log("第一个func1被执行了");
}
func1();
function func1(){
    console.log("第二个func1被执行了");
 }

 预解析结果：
 function func1(){
 console.log("第一个func1被执行了");
 }
 function func1(){
 console.log("第二个func1被执行了");
 }
 func1();
 func1();
 第一个func1被顶替了，输出的结果全部是：第二个func1被执行了
 ```
变量和函数同名：在提升的时候，如果有变量和函数同名，会只提升函数
```js
alert(foo);         //输出函数体
function foo(){}
var foo = 2;
alert(foo);         //输出2

预解析提升后的代码
 function foo(){}
 var foo;
 alert(foo);
 foo = 2;
 alert(foo);
 ```
变量的提升是分作用域的:
```js
 console.log(a);            //undefined
 var a = 123;

 function test1(){
 console.log(num);          //undefined
 var num = 10;
 }


var num = 456;
 function test2(){
    console.log(num);          //undefined
    var num = 10;
 }
//  提升结果：
 var num;
 num = 456;
 function test2(){
    var num;
    console.log(num);          //undefined
    num = 10;
 }


var num = 456;
function f1(){
    console.log(num);
    num = 10;
}
console.log(num);               //10
f1()                            //456
// 提升结果：
var num;
function f1(){
    console.log(num);
    num = 10;
}
num = 456;
console.log(num);
f1();
```

函数表达式不会被提升:
```js
func();                     //报错
var func = function(){
    console.log("func执行了！！");
}

预解析后代码
var func;
func();
func = function(){
 console.log("func执行了！！");
}
```
函数可以创造作用域，函数中又可以再创建函数，函数内部的作用域就可以访问外观的作用域
如果有多个函数嵌套，就会构成作用域链

```js
//条件式函数声明是否会被提升，取决于浏览器的不同。

foo();                      //报错，标准浏览器不支持这样的变量提升
if(true){
    function  foo() {
        console.log(123);
    }
}
```