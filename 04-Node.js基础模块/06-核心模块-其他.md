## 一 querystring模块

该模块有2个主要方法：
- querystring.parse()：将查询字符串反序列化为一个对象，类似JSON.parse()
- querystring.stringify()：将一个对象序列化为一个字符串对象，类似JSON.stringify()

```JavaScript
const querstring = require('querystring');
let str1 = 'username=lisi&password=123';
let obj1 = querstring.parse(str1);    //转换为了对象
let obj2 = {username: 'zs', password: '456'};
let str2 = querstring.stringify(obj2);  //重新转换为字符串
```

用户提交的网址一般包含一定的数据，比如 username=lisi 这样的参数，我们可以通过url.query获取到这些字符串数据，Node提供了querystring对象来对这个字符串数据进行实例化处理：
```JavaScript
let querystring = require('querystring');
urlStr = url.parse(req.url);
console.log(querystring.parse(urlStr));
```

## 二 path模块

API地址：http://nodejs.cn/api/path.html

该API用户获取路径：
```JavaScript
const path = require('path');
let myurl = path.join(__dirname, 'username', '123');
console.log(myurl);     //输出类似这样的绝对路径 E:\ProjectWeb\Test\username\123
```

__dirname 和 path.dirname 的区别:
```js
console.log(__dirname);  // 指向被执行 js 文件的绝对路径,包含的有文件名称
console.log(path.dirname('/abc/www/abc.txt'));  // 只有路径，没有文件名称
```

获取路径的最后一部分：
```js
path.basename('/foo/bar/aaa.html')              // 得到的结果是： aaa.html

path.basename('/foo/bar/aaa.html', '.html')     // 得到的结果是： aaa
```

获取扩展名:
```js
// 如果后面只是个‘.’，那么得到的就是‘.’； 如果没有扩展名，得到的就是空
path.extname('index.html')                      // 得到的结果： ‘.html’
```

路径的格式化处理：
```js
    let obj = {
        root: 'd:\\',
        base: 'abc.txt',
        ext: '.txt',
        name: 'abc'
    }

    console.log(path.format(obj));       //  输出的结果：d:\abc.txt
```


路径字符串转成对象
```js
    console.log(path.parse(__filename));
   //  输出的结果：
    {
        root: '文件根路径',
        dir: '文件的全路径',
        base: '文件名称',
        ext: '扩展名',
        name: '文件名称'
    }
```

连接路径：
```js
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
// 返回: '/foo/bar/baz/asdf'

path.join('foo', {}, 'bar');
// 抛出 'TypeError: Path must be a string. Received {}'
```

## 六 压缩模块 zlib

示例：
```JavaScript
const zlib = require('zlib');
const fs = require('fs');
let rs = fs.createReadStream('./1.jpg');
let ws = fs.createWriteStream('./2.gz');
let gz = zlib.createGzip();
rs.pipe(gz).pipe(ws);
ws.on('finish',()=>{
    console.log('完成');
});
```

可以使用gzip与stream优化服务端代码：极大减小响应文件代码。
```JavaScript
const http = require('http');
const zlib = require('zlib');
const fs = require('fs');
http.createServer((req,res)=>{
    let rs = fs.createReadStream(`文件地址`);
	//没有该句会变成下载
    res.setHeader('content-encoding','gzip');	
    let gz = zlib.createGzip();
    rs.pipe(gz).pipe(res);
    rs.on('error',err=>{
        res.writeHeader(404);
        res.write('Not found');
        res.end();
    });
}).listen(8000);
```